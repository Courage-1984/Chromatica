"""
Query processing module for the Chromatica color search engine.

This module provides functionality to convert user query parameters (hex colors and weights)
into query histograms that can be used for similarity search. The implementation follows
the same histogram generation principles as the image processing pipeline, ensuring
consistency between query and target representations.

Key Features:
- Hex color code to CIE Lab conversion using skimage
- Soft assignment to create "softened" query histograms
- L1 normalization for consistent distance calculations
- Support for weighted color queries

The query histograms generated by this module are designed to work seamlessly with
the FAISS HNSW index and Sinkhorn-EMD reranking stage.
"""

import numpy as np
from typing import List, Tuple, Optional
import logging
from skimage import color

from ..utils.config import L_BINS, A_BINS, B_BINS, TOTAL_BINS, LAB_RANGES

# Set up logging for this module
logger = logging.getLogger(__name__)


def hex_to_lab(hex_color: str) -> Tuple[float, float, float]:
    """
    Converts a hex color code to CIE Lab color space values.

    This function converts hex color codes (e.g., "#FF0000") to RGB values,
    then converts RGB to CIE Lab using the D65 illuminant. The conversion
    follows the same process used in the image processing pipeline to ensure
    consistency between query and target color representations.

    Args:
        hex_color: Hex color code string (e.g., "#FF0000", "FF0000", "#F00").
                  Supports both 3-digit and 6-digit hex codes.
                  The '#' prefix is optional.

    Returns:
        Tuple[float, float, float]: Lab color values as (L*, a*, b*).
                                   L* is in range [0, 100]
                                   a* is in range [-86, 98]
                                   b* is in range [-108, 95]

    Raises:
        ValueError: If hex_color is not a valid hex color code.
        RuntimeError: If color conversion fails.

    Example:
        >>> lab = hex_to_lab("#FF0000")
        >>> print(f"Red in Lab: L*={lab[0]:.2f}, a*={lab[1]:.2f}, b*={lab[2]:.2f}")
        Red in Lab: L*=53.24, a*=80.09, b*=67.20
    """
    # Input validation
    if not isinstance(hex_color, str):
        raise ValueError(f"hex_color must be a string, got {type(hex_color)}")

    # Clean the hex color string
    hex_color = hex_color.strip().upper()
    if hex_color.startswith("#"):
        hex_color = hex_color[1:]

    # Validate hex format
    if not all(c in "0123456789ABCDEF" for c in hex_color):
        raise ValueError(f"Invalid hex color format: {hex_color}")

    # Handle 3-digit hex codes (e.g., "F00" -> "FF0000")
    if len(hex_color) == 3:
        hex_color = "".join([c + c for c in hex_color])
    elif len(hex_color) != 6:
        raise ValueError(f"Hex color must be 3 or 6 characters, got {len(hex_color)}")

    try:
        # Convert hex to RGB values (0-255)
        r = int(hex_color[0:2], 16)
        g = int(hex_color[2:4], 16)
        b = int(hex_color[4:6], 16)

        # Convert RGB (0-255) to RGB (0-1) for skimage
        rgb = np.array([[r / 255.0, g / 255.0, b / 255.0]])

        # Convert RGB to Lab using skimage (D65 illuminant)
        lab = color.rgb2lab(rgb, illuminant="D65")

        # Extract Lab values and validate ranges
        l_val, a_val, b_val = lab[0, 0], lab[0, 1], lab[0, 2]

        # Validate Lab ranges
        if not (LAB_RANGES[0][0] <= l_val <= LAB_RANGES[0][1]):
            logger.warning(
                f"L* value {l_val:.2f} outside expected range {LAB_RANGES[0]}"
            )
        if not (LAB_RANGES[1][0] <= a_val <= LAB_RANGES[1][1]):
            logger.warning(
                f"a* value {a_val:.2f} outside expected range {LAB_RANGES[1]}"
            )
        if not (LAB_RANGES[2][0] <= b_val <= LAB_RANGES[2][1]):
            logger.warning(
                f"b* value {b_val:.2f} outside expected range {LAB_RANGES[2]}"
            )

        return float(l_val), float(a_val), float(b_val)

    except Exception as e:
        raise RuntimeError(f"Failed to convert hex color {hex_color} to Lab: {str(e)}")


def create_query_histogram(colors: List[str], weights: List[float]) -> np.ndarray:
    """
    Creates a "softened" query histogram from hex colors and weights.

    This function converts a list of hex color codes to CIE Lab values and creates
    a query histogram by distributing weights to the nearest bins using soft assignment.
    The resulting histogram is L1-normalized to create a probability distribution
    suitable for similarity calculations.

    The soft assignment approach ensures that query colors are represented as
    distributions rather than single points, making the search more robust to
    minor color variations and improving the quality of color-based image retrieval.

    Mathematical Process:
    1. Convert each hex color to Lab values
    2. For each color, distribute its weight to the 8 nearest bin centers
    3. Use tri-linear interpolation weights for smooth distribution
    4. Sum contributions from all colors
    5. L1-normalize to create a probability distribution

    Args:
        colors: List of hex color codes (e.g., ["#FF0000", "#00FF00"]).
               Each color will be converted to Lab space and contribute to the histogram.
        weights: List of weights corresponding to each color.
                Weights determine the relative importance of each color in the query.
                Must have the same length as colors.
                Weights are automatically normalized if they don't sum to 1.0.

    Returns:
        np.ndarray: A flattened, L1-normalized query histogram of shape (1152,).
                   The histogram represents the weighted color distribution and sums to 1.0.

    Raises:
        ValueError: If colors and weights have different lengths, or if any color is invalid.
        RuntimeError: If histogram generation fails.

    Example:
        >>> colors = ["#FF0000", "#00FF00", "#0000FF"]
        >>> weights = [0.5, 0.3, 0.2]
        >>> query_hist = create_query_histogram(colors, weights)
        >>> print(f"Query histogram shape: {query_hist.shape}")
        >>> print(f"Sum of histogram: {query_hist.sum():.6f}")
        Query histogram shape: (1152,)
        Sum of histogram: 1.000000
    """
    # Input validation
    if not isinstance(colors, list) or not isinstance(weights, list):
        raise ValueError("colors and weights must be lists")

    if len(colors) != len(weights):
        raise ValueError(
            f"colors and weights must have the same length, got {len(colors)} and {len(weights)}"
        )

    if len(colors) == 0:
        raise ValueError("colors list cannot be empty")

    if not all(isinstance(c, str) for c in colors):
        raise ValueError("All colors must be strings")

    if not all(isinstance(w, (int, float)) for w in weights):
        raise ValueError("All weights must be numeric")

    if not all(w >= 0 for w in weights):
        raise ValueError("All weights must be non-negative")

    # Normalize weights to sum to 1.0
    total_weight = sum(weights)
    if total_weight == 0:
        raise ValueError("Sum of weights must be greater than 0")

    normalized_weights = [w / total_weight for w in weights]

    # Initialize the query histogram
    query_hist = np.zeros(TOTAL_BINS, dtype=np.float64)

    try:
        # Process each color and its weight
        for color_hex, weight in zip(colors, normalized_weights):
            logger.debug(f"Processing color {color_hex} with weight {weight:.4f}")

            # Convert hex to Lab
            l_val, a_val, b_val = hex_to_lab(color_hex)

            # Convert Lab coordinates to continuous bin indices
            l_idx = (
                (l_val - LAB_RANGES[0][0])
                / (LAB_RANGES[0][1] - LAB_RANGES[0][0])
                * L_BINS
            )
            a_idx = (
                (a_val - LAB_RANGES[1][0])
                / (LAB_RANGES[1][1] - LAB_RANGES[1][0])
                * A_BINS
            )
            b_idx = (
                (b_val - LAB_RANGES[2][0])
                / (LAB_RANGES[2][1] - LAB_RANGES[2][0])
                * B_BINS
            )

            # Clamp indices to valid range
            l_idx = np.clip(l_idx, 0, L_BINS - 1)
            a_idx = np.clip(a_idx, 0, A_BINS - 1)
            b_idx = np.clip(b_idx, 0, B_BINS - 1)

            # Calculate integer bin indices and fractional parts
            l_floor, l_frac = int(np.floor(l_idx)), l_idx - np.floor(l_idx)
            a_floor, a_frac = int(np.floor(a_idx)), a_idx - np.floor(a_idx)
            b_floor, b_frac = int(np.floor(b_idx)), b_idx - np.floor(b_idx)

            # Ensure we don't go out of bounds
            l_floor = min(l_floor, L_BINS - 2)
            a_floor = min(a_floor, A_BINS - 2)
            b_floor = min(b_floor, B_BINS - 2)

            # Distribute weight to the 8 nearest bins using tri-linear interpolation
            # This creates the "softened" effect by spreading the color influence
            for dl in [0, 1]:
                for da in [0, 1]:
                    for db in [0, 1]:
                        # Calculate interpolation weight
                        l_weight = (1 - l_frac) if dl == 0 else l_frac
                        a_weight = (1 - a_frac) if da == 0 else a_frac
                        b_weight = (1 - b_frac) if db == 0 else b_frac

                        # Combined weight for this bin
                        bin_weight = l_weight * a_weight * b_weight * weight

                        # Calculate 3D bin index
                        l_bin = l_floor + dl
                        a_bin = a_floor + da
                        b_bin = b_floor + db

                        # Convert 3D index to 1D index
                        flat_idx = l_bin * A_BINS * B_BINS + a_bin * B_BINS + b_bin

                        # Add weight to the histogram
                        query_hist[flat_idx] += bin_weight

        # L1-normalize the histogram
        hist_sum = query_hist.sum()
        if hist_sum == 0:
            raise RuntimeError("Generated query histogram has zero sum")

        query_hist = query_hist / hist_sum

        # Validate the result
        if not np.allclose(query_hist.sum(), 1.0, atol=1e-6):
            raise RuntimeError(
                f"Query histogram normalization failed, sum = {query_hist.sum():.6f}"
            )

        logger.info(f"Successfully created query histogram with {len(colors)} colors")
        logger.debug(
            f"Query histogram shape: {query_hist.shape}, sum: {query_hist.sum():.6f}"
        )

        return query_hist

    except Exception as e:
        logger.error(f"Failed to create query histogram: {str(e)}")
        raise RuntimeError(f"Query histogram generation failed: {str(e)}")


def validate_query_histogram(histogram: np.ndarray) -> bool:
    """
    Validates that a query histogram meets the required specifications.

    This function performs comprehensive validation of query histograms to ensure
    they are compatible with the search and reranking pipeline. The validation
    checks match the requirements for image histograms to maintain consistency.

    Args:
        histogram: The query histogram to validate.

    Returns:
        bool: True if the histogram is valid, False otherwise.

    Example:
        >>> colors = ["#FF0000", "#00FF00"]
        >>> weights = [0.6, 0.4]
        >>> query_hist = create_query_histogram(colors, weights)
        >>> is_valid = validate_query_histogram(query_hist)
        >>> print(f"Histogram is valid: {is_valid}")
        Histogram is valid: True
    """
    try:
        # Check shape
        if histogram.shape != (TOTAL_BINS,):
            logger.error(
                f"Invalid histogram shape: {histogram.shape}, expected ({TOTAL_BINS},)"
            )
            return False

        # Check data type
        if not np.issubdtype(histogram.dtype, np.floating):
            logger.error(f"Invalid histogram dtype: {histogram.dtype}, expected float")
            return False

        # Check for NaN or infinite values
        if not np.all(np.isfinite(histogram)):
            logger.error("Histogram contains NaN or infinite values")
            return False

        # Check for negative values
        if np.any(histogram < 0):
            logger.error("Histogram contains negative values")
            return False

        # Check L1 normalization (should sum to 1.0)
        hist_sum = histogram.sum()
        if not np.allclose(hist_sum, 1.0, atol=1e-6):
            logger.error(f"Histogram is not L1-normalized, sum = {hist_sum:.6f}")
            return False

        logger.debug("Query histogram validation passed")
        return True

    except Exception as e:
        logger.error(f"Histogram validation failed: {str(e)}")
        return False
