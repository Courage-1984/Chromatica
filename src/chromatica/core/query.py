"""
Query processing module for the Chromatica color search engine.

This module provides functionality to convert user query parameters (hex colors and weights)
into query histograms that can be used for similarity search. The implementation follows
the same histogram generation principles as the image processing pipeline, ensuring
consistency between query and target representations.

Key Features:
- Hex color code to CIE Lab conversion using skimage
- **NEW: Weight normalization for API compatibility**
- Soft assignment to create "softened" query histograms
- L1 normalization for consistent distance calculations
- Support for weighted color queries

The query histograms generated by this module are designed to work seamlessly with
the FAISS HNSW index and Sinkhorn-EMD reranking stage.
"""

import numpy as np
from typing import List, Tuple, Optional, Union
import logging
from skimage import color

# Assuming these imports are from ..utils.config
try:
    from ..utils.config import L_BINS, A_BINS, B_BINS, TOTAL_BINS, LAB_RANGES
    from ..utils.config import QUERY_SHARPEN_EXPONENT
except ImportError:
    # Placeholder values for standalone testing if needed
    L_BINS = 8
    A_BINS = 12
    B_BINS = 12
    TOTAL_BINS = L_BINS * A_BINS * B_BINS  # 1152
    LAB_RANGES = [[0, 100], [-86, 98], [-108, 95]]
    QUERY_SHARPEN_EXPONENT = 1.0


# Set up logging for this module
logger = logging.getLogger(__name__)


def normalize_weights(weights: List[Union[int, float]]) -> List[float]:
    """
    Normalizes a list of weights to sum to 1.0.

    Args:
        weights: List of integer or float weights.

    Returns:
        List[float]: Normalized weights.

    Raises:
        ValueError: If the sum of weights is zero or negative.
    """
    if not weights:
        return []

    total_weight = sum(weights)
    if total_weight <= 0:
        raise ValueError("Sum of weights must be greater than 0 for normalization")

    return [float(w) / total_weight for w in weights]


def hex_to_lab(hex_color: str) -> Tuple[float, float, float]:
    """
    Converts a hex color code to CIE Lab color space values.

    This function converts hex color codes (e.g., "#FF0000") to RGB values,
    then converts RGB to CIE Lab using the D65 illuminant. The conversion
    follows the same process used in the image processing pipeline to ensure
    consistency between query and target color representations.

    Args:
        hex_color: Hex color code string (e.g., "#FF0000", "FF0000", "#F00").
                  Supports both 3-digit and 6-digit hex codes.
                  The '#' prefix is optional.

    Returns:
        Tuple[float, float, float]: Lab color values as (L*, a*, b*).
                                   L* is in range [0, 100]
                                   a* is in range [-86, 98]
                                   b* is in range [-108, 95]

    Raises:
        ValueError: If hex_color is not a valid hex color code.
        RuntimeError: If color conversion fails.

    Example:
        >>> lab = hex_to_lab("#FF0000")
        >>> print(f"Red in Lab: L*={lab[0]:.2f}, a*={lab[1]:.2f}, b*={lab[2]:.2f}")
        Red in Lab: L*=53.24, a*=80.09, b*=67.20
    """
    # Input validation
    if not isinstance(hex_color, str):
        raise ValueError(f"hex_color must be a string, got {type(hex_color)}")

    # Clean the hex color string
    hex_color = hex_color.strip().upper()
    if hex_color.startswith("#"):
        hex_color = hex_color[1:]

    # Validate hex format
    if not all(c in "0123456789ABCDEF" for c in hex_color):
        raise ValueError(f"Invalid hex color format: {hex_color}")

    # Handle 3-digit hex codes (e.g., "F00" -> "FF0000")
    if len(hex_color) == 3:
        hex_color = "".join([c + c for c in hex_color])
    elif len(hex_color) != 6:
        raise ValueError(f"Hex color must be 3 or 6 characters, got {len(hex_color)}")

    try:
        # Convert hex to RGB values (0-255)
        r = int(hex_color[0:2], 16)
        g = int(hex_color[2:4], 16)
        b = int(hex_color[4:6], 16)

        # Convert RGB (0-255) to RGB (0-1) for skimage
        rgb = np.array([[r / 255.0, g / 255.0, b / 255.0]])

        # Convert RGB to Lab using skimage (D65 illuminant)
        lab = color.rgb2lab(rgb, illuminant="D65")

        # Extract Lab values and validate ranges
        l_val, a_val, b_val = lab[0, 0], lab[0, 1], lab[0, 2]

        # Validate Lab ranges
        if not (LAB_RANGES[0][0] <= l_val <= LAB_RANGES[0][1]):
            logger.warning(
                f"L* value {l_val:.2f} outside expected range {LAB_RANGES[0]}"
            )
        if not (LAB_RANGES[1][0] <= a_val <= LAB_RANGES[1][1]):
            logger.warning(
                f"a* value {a_val:.2f} outside expected range {LAB_RANGES[1]}"
            )
        if not (LAB_RANGES[2][0] <= b_val <= LAB_RANGES[2][1]):
            logger.warning(
                f"b* value {b_val:.2f} outside expected range {LAB_RANGES[2]}"
            )

        return float(l_val), float(a_val), float(b_val)

    except Exception as e:
        raise RuntimeError(f"Failed to convert hex color {hex_color} to Lab: {str(e)}")


def create_query_histogram(colors: List[str], weights: List[float], sharpen_exponent: Optional[float] = None) -> np.ndarray:
    """
    Creates a "softened" query histogram from hex colors and weights.

    (Docstring truncated for brevity)
    """
    # Input validation
    if not isinstance(colors, list) or not isinstance(weights, list):
        raise ValueError("colors and weights must be lists")

    if len(colors) != len(weights):
        raise ValueError(
            f"colors and weights must have the same length, got {len(colors)} and {len(weights)}"
        )

    if len(colors) == 0:
        raise ValueError("colors list cannot be empty")

    if not all(isinstance(c, str) for c in colors):
        raise ValueError("All colors must be strings")

    if not all(isinstance(w, (int, float)) for w in weights):
        raise ValueError("All weights must be numeric")

    if not all(w >= 0 for w in weights):
        raise ValueError("All weights must be non-negative")

    # Normalize weights to sum to 1.0 (FIXED: using the new function)
    try:
        normalized_weights = normalize_weights(weights)
    except ValueError as e:
        raise ValueError(str(e))

    # Initialize the query histogram
    query_hist = np.zeros(TOTAL_BINS, dtype=np.float64)

    try:
        # Process each color and its weight
        for color_hex, weight in zip(colors, normalized_weights):
            logger.debug(f"Processing color {color_hex} with weight {weight:.4f}")

            # Convert hex to Lab
            l_val, a_val, b_val = hex_to_lab(color_hex)

            # Convert Lab coordinates to continuous bin indices
            l_idx = (
                (l_val - LAB_RANGES[0][0])
                / (LAB_RANGES[0][1] - LAB_RANGES[0][0])
                * L_BINS
            )
            a_idx = (
                (a_val - LAB_RANGES[1][0])
                / (LAB_RANGES[1][1] - LAB_RANGES[1][0])
                * A_BINS
            )
            b_idx = (
                (b_val - LAB_RANGES[2][0])
                / (LAB_RANGES[2][1] - LAB_RANGES[2][0])
                * B_BINS
            )

            # Clamp indices to valid range
            l_idx = np.clip(l_idx, 0, L_BINS - 1)
            a_idx = np.clip(a_idx, 0, A_BINS - 1)
            b_idx = np.clip(b_idx, 0, B_BINS - 1)

            # Calculate integer bin indices and fractional parts
            l_floor, l_frac = int(np.floor(l_idx)), l_idx - np.floor(l_idx)
            a_floor, a_frac = int(np.floor(a_idx)), a_idx - np.floor(a_idx)
            b_floor, b_frac = int(np.floor(b_idx)), b_idx - np.floor(b_idx)

            # Ensure we don't go out of bounds
            l_floor = min(l_floor, L_BINS - 2)
            a_floor = min(a_floor, A_BINS - 2)
            b_floor = min(b_floor, B_BINS - 2)

            # Distribute weight to the 8 nearest bins using tri-linear interpolation
            # This creates the "softened" effect by spreading the color influence
            for dl in [0, 1]:
                for da in [0, 1]:
                    for db in [0, 1]:
                        # Calculate interpolation weight
                        l_weight = (1 - l_frac) if dl == 0 else l_frac
                        a_weight = (1 - a_frac) if da == 0 else a_frac
                        b_weight = (1 - b_frac) if db == 0 else b_frac

                        # Combined weight for this bin
                        bin_weight = l_weight * a_weight * b_weight * weight

                        # Calculate 3D bin index
                        l_bin = l_floor + dl
                        a_bin = a_floor + da
                        b_bin = b_floor + db

                        # Convert 3D index to 1D index
                        flat_idx = l_bin * A_BINS * B_BINS + a_bin * B_BINS + b_bin

                        # Add weight to the histogram
                        query_hist[flat_idx] += bin_weight

        # L1-normalize the histogram
        hist_sum = query_hist.sum()
        if hist_sum == 0:
            # Should not happen if weights > 0, but as a safeguard:
            # We already normalized, so this check is redundant but kept for safety.
            raise RuntimeError(
                "Generated query histogram has zero sum after L1-normalization"
            )

        # The histogram is already L1-normalized through `normalized_weights` and the
        # soft assignment mechanism. A final check is sufficient.

        # NOTE: A more accurate approach is to just check the final sum after the loop
        # and re-normalize, but given the current structure of soft-assignment, the
        # weights should sum close to 1.0. A final division for stability is best:
        query_hist = query_hist / hist_sum if hist_sum != 0 else query_hist

        # Optional sharpening to concentrate mass around peaks
        exp_val = sharpen_exponent if sharpen_exponent is not None else QUERY_SHARPEN_EXPONENT
        if exp_val and exp_val > 1.0:
            query_hist = np.power(np.maximum(query_hist, 0.0), exp_val)
            hist_sum = query_hist.sum()
            if hist_sum > 0:
                query_hist = query_hist / hist_sum

        # Validate the result
        if not np.allclose(query_hist.sum(), 1.0, atol=1e-6):
            raise RuntimeError(
                f"Query histogram normalization failed, sum = {query_hist.sum():.6f}"
            )

        logger.info(f"Successfully created query histogram with {len(colors)} colors")
        logger.debug(
            f"Query histogram shape: {query_hist.shape}, sum: {query_hist.sum():.6f}"
        )

        return query_hist

    except Exception as e:
        logger.error(f"Failed to create query histogram: {str(e)}")
        raise RuntimeError(f"Query histogram generation failed: {str(e)}")


def validate_query_histogram(histogram: np.ndarray) -> bool:
    """
    Validates that a query histogram meets the required specifications.

    (Docstring truncated for brevity)
    """
    try:
        # Check shape
        if histogram.shape != (TOTAL_BINS,):
            logger.error(
                f"Invalid histogram shape: {histogram.shape}, expected ({TOTAL_BINS},)"
            )
            return False

        # Check data type
        if not np.issubdtype(histogram.dtype, np.floating):
            logger.error(f"Invalid histogram dtype: {histogram.dtype}, expected float")
            return False

        # Check for NaN or infinite values
        if not np.all(np.isfinite(histogram)):
            logger.error("Histogram contains NaN or infinite values")
            return False

        # Check for negative values
        if np.any(histogram < 0):
            logger.error("Histogram contains negative values")
            return False

        # Check L1 normalization (should sum to 1.0)
        hist_sum = histogram.sum()
        if not np.allclose(hist_sum, 1.0, atol=1e-6):
            logger.error(f"Histogram is not L1-normalized, sum = {hist_sum:.6f}")
            return False

        logger.debug("Query histogram validation passed")
        return True

    except Exception as e:
        logger.error(f"Histogram validation failed: {str(e)}")
        return False

